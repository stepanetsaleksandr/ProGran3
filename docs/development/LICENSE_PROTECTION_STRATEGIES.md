# ğŸ” Ğ¡Ğ¢Ğ ĞĞ¢Ğ•Ğ“Ğ†Ğ‡ Ğ—ĞĞ¥Ğ˜Ğ¡Ğ¢Ğ£ Ğ›Ğ†Ğ¦Ğ•ĞĞ—Ğ£Ğ’ĞĞĞĞ¯ ProGran3

**Ğ”Ğ°Ñ‚Ğ°:** 12 Ğ¶Ğ¾Ğ²Ñ‚Ğ½Ñ 2025  
**ĞœĞµÑ‚Ğ°:** Ğ£Ğ½ĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¸Ñ‚Ğ¸ ĞºÑ€Ğ°Ğ´Ñ–Ğ¶ĞºÑƒ Ñ‚Ğ° Ğ½ĞµÑĞ°Ğ½ĞºÑ†Ñ–Ğ¾Ğ½Ğ¾Ğ²Ğ°Ğ½Ğµ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ  
**ĞĞ½Ğ°Ğ»Ñ–Ğ·:** 5 Ğ¿Ñ€Ğ¾Ñ„ĞµÑÑ–Ğ¹Ğ½Ğ¸Ñ… Ğ²Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚Ñ–Ğ²

---

## ğŸ¯ Ğ’Ğ˜ĞœĞĞ“Ğ˜ Ğ”Ğ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ˜

### Ğ—Ğ°Ñ…Ğ¸ÑÑ‚ Ğ²Ñ–Ğ´:
1. âŒ **ĞšĞ¾Ğ¿Ñ–ÑĞ²Ğ°Ğ½Ğ½Ñ Ğ½Ğ° Ñ–Ğ½ÑˆĞ¸Ğ¹ ĞºĞ¾Ğ¼Ğ¿'ÑÑ‚ĞµÑ€** - Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ¿Ñ€Ğ¸Ğ²'ÑĞ·Ğ°Ğ½Ğ° Ğ´Ğ¾ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸
2. âŒ **Ğ¡Ğ¿Ñ–Ğ»ÑŒĞ½Ğµ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ** - Ğ¾Ğ´Ğ½Ğ° Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ = Ğ¾Ğ´Ğ½Ğ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°
3. âŒ **Ğ—Ğ¼Ñ–Ğ½Ğ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ¾Ğ³Ğ¾ Ñ‡Ğ°ÑÑƒ** - Ğ¾Ğ±Ñ…Ñ–Ğ´ expiration
4. âŒ **Ğ ĞµĞ´Ğ°Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ ĞºĞ¾Ğ´Ñƒ** - obfuscation
5. âŒ **Offline Ğ¾Ğ±Ñ…Ñ–Ğ´** - Ğ²Ğ¸Ğ¼Ğ¾Ğ³Ğ° online Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¸
6. âŒ **ĞŸÑ–Ğ´Ñ€Ğ¾Ğ±ĞºĞ° Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ĞµĞ¹** - ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ñ–Ñ‡Ğ½Ñ– Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑĞ¸

### ĞŸĞ¾Ñ‚Ñ€Ñ–Ğ±Ğ½Ğ¾:
- âœ… ĞŸÑ€Ğ°Ñ†ÑĞ²Ğ°Ñ‚Ğ¸ online Ñ‚Ğ° offline (graceful)
- âœ… ĞĞµ Ğ·Ğ°Ğ²Ğ°Ğ¶Ğ°Ñ‚Ğ¸ Ğ»ĞµĞ³Ñ–Ñ‚Ğ¸Ğ¼Ğ½Ğ¸Ğ¼ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°Ğ¼
- âœ… Ğ¨Ğ²Ğ¸Ğ´ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° (<500ms)
- âœ… ĞĞ°Ğ´Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ 99.9%
- âœ… ĞœĞ¾Ğ¶Ğ»Ğ¸Ğ²Ñ–ÑÑ‚ÑŒ Ğ´ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ñ–Ñ— Ğ²Ñ–Ğ´Ğ´Ğ°Ğ»ĞµĞ½Ğ¾

---

## ğŸ† Ğ’ĞĞ Ğ†ĞĞĞ¢ 1: HARDWARE FINGERPRINTING + ONLINE VALIDATION

### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ñ–Ñ: "ĞŸÑ€Ğ¸Ğ²'ÑĞ·ĞºĞ° Ğ´Ğ¾ Ğ·Ğ°Ğ»Ñ–Ğ·a + ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞºĞ¾Ğ¶ĞµĞ½ Ğ·Ğ°Ğ¿ÑƒÑĞº"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. STARTUP                          â”‚
â”‚     â”œâ”€ Generate hardware fingerprintâ”‚
â”‚     â”œâ”€ Online validation (required) â”‚
â”‚     â””â”€ Block if invalid             â”‚
â”‚                                      â”‚
â”‚  2. RUNTIME                          â”‚
â”‚     â”œâ”€ Periodic heartbeat (5 min)   â”‚
â”‚     â”œâ”€ Re-validate online           â”‚
â”‚     â””â”€ Block if connection lost     â”‚
â”‚                                      â”‚
â”‚  3. PROTECTION                       â”‚
â”‚     â”œâ”€ Unique per machine           â”‚
â”‚     â”œâ”€ Can't transfer license       â”‚
â”‚     â””â”€ Server-side control          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ:

#### 1. Hardware Fingerprinting (Ruby):
```ruby
module ProGran3::Security
  class HardwareFingerprint
    def self.generate
      components = {
        # Ğ£Ğ½Ñ–ĞºĞ°Ğ»ÑŒĞ½Ñ– Ğ°Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ñ– Ñ–Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ‚Ğ¾Ñ€Ğ¸
        motherboard: get_motherboard_serial,
        cpu: get_cpu_id,
        mac: get_primary_mac_address,
        disk: get_disk_serial,
        
        # Ğ”Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ñ– Ñ–Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ‚Ğ¾Ñ€Ğ¸
        hostname: Socket.gethostname.downcase,
        username: ENV['USERNAME'] || ENV['USER'],
        
        # Ğ—Ğ°Ñ…Ğ¸ÑÑ‚ Ğ²Ñ–Ğ´ VM
        is_virtual: detect_virtual_machine
      }
      
      # SHA256 hash Ğ²ÑÑ–Ñ… ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ–Ğ²
      data_string = components.sort.to_h.to_json
      fingerprint = Digest::SHA256.hexdigest(data_string)
      
      # Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¸ Ğ¾ĞºÑ€ĞµĞ¼Ğ¾ Ğ´Ğ»Ñ debug
      {
        fingerprint: fingerprint,
        components: components,
        timestamp: Time.now.to_i
      }
    end
    
    private
    
    def self.get_motherboard_serial
      if RUBY_PLATFORM.include?('mingw')
        result = `wmic baseboard get serialnumber /value 2>nul`
        serial = result.scan(/SerialNumber=(.+)/).flatten.first&.strip
        return serial if serial && serial != 'To be filled by O.E.M.'
      end
      'unknown'
    end
    
    def self.get_cpu_id
      if RUBY_PLATFORM.include?('mingw')
        result = `wmic cpu get processorid /value 2>nul`
        result.scan(/ProcessorId=(.+)/).flatten.first&.strip || 'unknown'
      else
        'unknown'
      end
    end
    
    def self.get_primary_mac_address
      if RUBY_PLATFORM.include?('mingw')
        result = `getmac /v /fo csv 2>nul`
        macs = result.scan(/"([A-F0-9-]{17})"/).flatten
        
        # Ğ¤Ñ–Ğ»ÑŒÑ‚Ñ€ÑƒÑ”Ğ¼Ğ¾ Ğ²Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ– Ğ°Ğ´Ğ°Ğ¿Ñ‚ĞµÑ€Ğ¸
        physical = macs.reject { |mac| virtual_mac?(mac) }
        physical.first || 'unknown'
      else
        'unknown'
      end
    end
    
    def self.get_disk_serial
      if RUBY_PLATFORM.include?('mingw')
        result = `wmic diskdrive get serialnumber /value 2>nul`
        result.scan(/SerialNumber=(.+)/).flatten.first&.strip || 'unknown'
      else
        'unknown'
      end
    end
    
    def self.detect_virtual_machine
      if RUBY_PLATFORM.include?('mingw')
        result = `wmic computersystem get model 2>nul`
        result.downcase.include?('virtual') || result.downcase.include?('vmware')
      else
        false
      end
    end
    
    def self.virtual_mac?(mac)
      virtual_prefixes = [
        '00:05:69', '00:0C:29', '00:1C:14', '00:50:56', # VMware
        '08:00:27', '0A:00:27',                         # VirtualBox
        '00:15:5D',                                      # Hyper-V
        '00:16:3E'                                       # Xen
      ]
      virtual_prefixes.any? { |prefix| mac.upcase.start_with?(prefix) }
    end
  end
end
```

#### 2. Online Validation:
```ruby
module ProGran3::Security
  class StrictLicenseManager
    def initialize
      @api_client = ApiClient.new
      @max_offline_time = 30 * 60 # 30 minutes
    end
    
    def validate_on_startup
      fingerprint = HardwareFingerprint.generate
      
      # ĞĞ‘ĞĞ’'Ğ¯Ğ—ĞšĞĞ’Ğ online Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºÑƒ
      result = @api_client.validate_license(fingerprint[:fingerprint])
      
      if result[:success] && result[:valid]
        # Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ Ğ· timestamp
        save_validation(result, Time.now)
        return { valid: true, license: result[:license] }
      else
        return { valid: false, error: result[:error] }
      end
    end
    
    def check_during_runtime
      last_validation = load_last_validation
      
      # Ğ¯ĞºÑ‰Ğ¾ Ğ¿Ñ€Ğ¾Ğ¹ÑˆĞ»Ğ¾ Ğ±Ñ–Ğ»ÑŒÑˆĞµ 30 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½ - Ğ²Ğ¸Ğ¼Ğ°Ğ³Ğ°Ñ”Ğ¼Ğ¾ online Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ
      if !last_validation || (Time.now - last_validation[:timestamp] > @max_offline_time)
        return validate_on_startup
      end
      
      # Ğ†Ğ½Ğ°ĞºÑˆĞµ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ ĞºĞµÑˆ
      { valid: true, cached: true }
    end
  end
end
```

#### 3. Ğ†Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ Ğ² Ğ¿Ğ»Ğ°Ğ³Ñ–Ğ½:
```ruby
# proGran3.rb
module ProGran3
  def self.can_start_plugin?
    license_mgr = Security::StrictLicenseManager.new
    result = license_mgr.validate_on_startup
    
    if result[:valid]
      Logger.success("Ğ›Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ²Ğ°Ğ»Ñ–Ğ´Ğ½Ğ°", "Main")
      true
    else
      show_license_error(result[:error])
      false
    end
  end
  
  # Ğ£ ÑÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ– toolbar
  cmd = UI::Command.new("ProGran3") {
    if can_start_plugin?
      SplashScreen.show
    else
      UI.messagebox("Ğ›Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ğ°Ğ±Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡ĞµĞ½Ğ°")
    end
  }
end
```

### âœ… ĞŸĞµÑ€ĞµĞ²Ğ°Ğ³Ğ¸:
- â­â­â­â­â­ **Ğ”ÑƒĞ¶Ğµ Ğ²Ğ¸ÑĞ¾ĞºĞ¸Ğ¹ Ñ€Ñ–Ğ²ĞµĞ½ÑŒ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚Ñƒ**
- ĞĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¾ Ğ¿ĞµÑ€ĞµĞ½ĞµÑÑ‚Ğ¸ Ğ½Ğ° Ñ–Ğ½ÑˆĞ¸Ğ¹ ĞŸĞš
- Server-side ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒ (Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ´ĞµĞ°ĞºÑ‚Ğ¸Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸)
- Ğ’Ğ¸ÑĞ²Ğ»ÑÑ” Ğ²Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ– Ğ¼Ğ°ÑˆĞ¸Ğ½Ğ¸

### âŒ ĞĞµĞ´Ğ¾Ğ»Ñ–ĞºĞ¸:
- ĞŸĞ¾Ñ‚Ñ€ĞµĞ±ÑƒÑ” internet Ğ¿Ñ€Ğ¸ ĞšĞĞ–ĞĞĞœĞ£ Ğ·Ğ°Ğ¿ÑƒÑĞºÑƒ
- Ğ¯ĞºÑ‰Ğ¾ ÑĞµÑ€Ğ²ĞµÑ€ down = Ğ¿Ğ»Ğ°Ğ³Ñ–Ğ½ Ğ½Ğµ Ğ¿Ñ€Ğ°Ñ†ÑÑ”
- ĞŸĞ¾Ğ³Ğ°Ğ½Ğ° UX Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ³Ğ°Ğ½Ğ¾Ğ¼Ñƒ Ñ–Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚Ñ–

### ğŸ“Š ĞÑ†Ñ–Ğ½ĞºĞ¸:
- **Ğ—Ğ°Ñ…Ğ¸ÑÑ‚:** 9/10 ğŸŸ¢
- **UX:** 5/10 ğŸŸ¡
- **Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ:** 7/10 ğŸŸ¡
- **ĞĞ°Ğ´Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ:** 6/10 ğŸŸ¡ (Ğ·Ğ°Ğ»ĞµĞ¶Ğ¸Ñ‚ÑŒ Ğ²Ñ–Ğ´ ÑĞµÑ€Ğ²ĞµÑ€Ğ°)

**ĞšĞ¾Ğ»Ğ¸ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸:** Enterprise ĞºĞ»Ñ–Ñ”Ğ½Ñ‚Ğ¸ Ğ· Ğ¿Ğ¾ÑÑ‚Ñ–Ğ¹Ğ½Ğ¸Ğ¼ Ñ–Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚Ğ¾Ğ¼

---

## ğŸ† Ğ’ĞĞ Ğ†ĞĞĞ¢ 2: OFFLINE FIRST + PERIODIC VALIDATION (Ğ Ğ•ĞšĞĞœĞ•ĞĞ”ĞĞ’ĞĞĞ!)

### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ñ–Ñ: "ĞŸÑ€Ğ°Ñ†ÑÑ” offline, Ğ°Ğ»Ğµ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ” online Ğ¿ĞµÑ€Ñ–Ğ¾Ğ´Ğ¸Ñ‡Ğ½Ğ¾"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. STARTUP                          â”‚
â”‚     â”œâ”€ Check local license file     â”‚
â”‚     â”œâ”€ If valid â†’ Start immediately â”‚
â”‚     â””â”€ Background online check      â”‚
â”‚                                      â”‚
â”‚  2. BACKGROUND VALIDATION            â”‚
â”‚     â”œâ”€ Every 24 hours online check  â”‚
â”‚     â”œâ”€ Update local cache           â”‚
â”‚     â””â”€ Continue if offline          â”‚
â”‚                                      â”‚
â”‚  3. GRACE PERIOD                     â”‚
â”‚     â”œâ”€ 7 days offline maximum       â”‚
â”‚     â”œâ”€ After 7 days â†’ require onlineâ”‚
â”‚     â””â”€ Soft warning after 3 days    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ:

#### 1. Smart License Manager:
```ruby
module ProGran3::Security
  class SmartLicenseManager
    GRACE_PERIOD_DAYS = 7
    WARNING_PERIOD_DAYS = 3
    VALIDATION_INTERVAL = 24 * 60 * 60 # 24 hours
    
    def validate_license
      # 1. Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ÑƒÑ”Ğ¼Ğ¾ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñƒ Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ
      local_license = LicenseStorage.load
      
      # 2. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñƒ Ğ²Ğ°Ğ»Ñ–Ğ´Ğ½Ñ–ÑÑ‚ÑŒ
      if !local_license || expired?(local_license)
        return requires_activation
      end
      
      # 3. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ fingerprint
      current_fp = HardwareFingerprint.generate[:fingerprint]
      if local_license[:fingerprint] != current_fp
        return { 
          valid: false, 
          error: 'license_transfer_detected',
          message: 'Ğ›Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ¿Ñ€Ğ¸Ğ²\'ÑĞ·Ğ°Ğ½Ğ° Ğ´Ğ¾ Ñ–Ğ½ÑˆĞ¾Ğ³Ğ¾ ĞºĞ¾Ğ¼Ğ¿\'ÑÑ‚ĞµÑ€Ğ°'
        }
      end
      
      # 4. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ grace period
      last_online = local_license[:last_validation] || local_license[:activated_at]
      days_offline = (Time.now - Time.parse(last_online)) / 86400
      
      if days_offline > GRACE_PERIOD_DAYS
        # Ğ’Ğ¸Ğ¼Ğ°Ğ³Ğ°Ñ”Ğ¼Ğ¾ online Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ
        return validate_online_required(local_license)
      elsif days_offline > WARNING_PERIOD_DAYS
        # ĞŸĞ¾ĞºĞ°Ğ·ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ğ¾Ğ¿ĞµÑ€ĞµĞ´Ğ¶ĞµĞ½Ğ½Ñ Ğ°Ğ»Ğµ Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¿Ñ€Ğ°Ñ†ÑĞ²Ğ°Ñ‚Ğ¸
        validate_online_background(local_license)
        return {
          valid: true,
          warning: "Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğ¸ÑÑŒ Ğ´Ğ¾ Ñ–Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚Ñƒ (#{days_offline.to_i} Ğ´Ğ½Ñ–Ğ² offline)"
        }
      else
        # Ğ’ÑĞµ OK, background validation
        validate_online_background(local_license)
        return { valid: true, offline_mode: days_offline > 1 }
      end
    end
    
    private
    
    def validate_online_required(license)
      result = ApiClient.validate_online(license[:license_key])
      
      if result[:success]
        # ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ local cache
        license[:last_validation] = Time.now.iso8601
        LicenseStorage.save(license)
        return { valid: true }
      else
        return { 
          valid: false, 
          error: 'online_validation_required',
          message: 'ĞĞµĞ¾Ğ±Ñ…Ñ–Ğ´Ğ½Ğµ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ´Ğ¾ Ñ–Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚Ñƒ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¸ Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ—'
        }
      end
    end
    
    def validate_online_background(license)
      # Async Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ² background
      Thread.new do
        result = ApiClient.validate_online(license[:license_key])
        
        if result[:success] && result[:valid]
          license[:last_validation] = Time.now.iso8601
          LicenseStorage.save(license)
          Logger.info("Background validation ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ°", "License")
        elsif !result[:offline]
          # Ğ›Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ±Ñ–Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ²Ğ°Ğ»Ñ–Ğ´Ğ½Ğ° Ğ½Ğ° ÑĞµÑ€Ğ²ĞµÑ€Ñ–
          Logger.warn("Ğ›Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ´ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ½Ğ° ÑĞµÑ€Ğ²ĞµÑ€Ñ–", "License")
          # ĞœĞ¾Ğ¶Ğ½Ğ° Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ warning ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñƒ
        end
      end
    end
    
    def expired?(license)
      return false unless license[:expires_at]
      Time.parse(license[:expires_at]) < Time.now
    end
    
    def requires_activation
      {
        valid: false,
        error: 'activation_required',
        message: 'ĞŸĞ¾Ñ‚Ñ€Ñ–Ğ±Ğ½Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ñ–Ñ Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ—'
      }
    end
  end
end
```

#### 2. Encrypted Local Storage:
```ruby
module ProGran3::Security
  class LicenseStorage
    LICENSE_FILE = File.join(Dir.home, '.progran3', 'license.enc')
    
    def self.save(license_data)
      # Encrypt Ğ¿ĞµÑ€ĞµĞ´ Ğ·Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½ÑĞ¼
      encrypted = encrypt_data(license_data)
      
      FileUtils.mkdir_p(File.dirname(LICENSE_FILE))
      File.write(LICENSE_FILE, encrypted)
      
      # ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ñ„Ğ°Ğ¹Ğ» (Windows)
      if RUBY_PLATFORM.include?('mingw')
        system("attrib +h +s \"#{LICENSE_FILE}\"")
      else
        File.chmod(0600, LICENSE_FILE)
      end
    end
    
    def self.load
      return nil unless File.exist?(LICENSE_FILE)
      
      encrypted = File.read(LICENSE_FILE)
      decrypt_data(encrypted)
    rescue => e
      Logger.error("Failed to load license: #{e.message}", "Storage")
      nil
    end
    
    private
    
    def self.encrypt_data(data)
      require 'openssl'
      
      # ĞšĞ»ÑÑ‡ Ğ±Ğ°Ğ·ÑƒÑ”Ñ‚ÑŒÑÑ Ğ½Ğ° hardware fingerprint
      key = derive_encryption_key
      cipher = OpenSSL::Cipher.new('AES-256-CBC')
      cipher.encrypt
      cipher.key = key
      iv = cipher.random_iv
      
      encrypted = cipher.update(data.to_json) + cipher.final
      
      # Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ IV + encrypted data
      Base64.strict_encode64(iv + encrypted)
    end
    
    def self.decrypt_data(encrypted_data)
      require 'openssl'
      
      decoded = Base64.strict_decode64(encrypted_data)
      
      key = derive_encryption_key
      cipher = OpenSSL::Cipher.new('AES-256-CBC')
      cipher.decrypt
      cipher.key = key
      
      # Ğ’Ğ¸Ñ‚ÑĞ³ÑƒÑ”Ğ¼Ğ¾ IV (Ğ¿ĞµÑ€ÑˆÑ– 16 Ğ±Ğ°Ğ¹Ñ‚)
      iv = decoded[0...16]
      encrypted = decoded[16..-1]
      
      cipher.iv = iv
      decrypted = cipher.update(encrypted) + cipher.final
      
      JSON.parse(decrypted, symbolize_names: true)
    end
    
    def self.derive_encryption_key
      # ĞšĞ»ÑÑ‡ Ğ±Ğ°Ğ·ÑƒÑ”Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ°Ğ¿Ğ°Ñ€Ğ°Ñ‚Ğ½Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ¸Ñ… (Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° ÑĞºĞ¾Ğ¿Ñ–ÑĞ²Ğ°Ñ‚Ğ¸)
      fp = HardwareFingerprint.generate
      salt = 'ProGran3-License-Encryption-v1'
      
      OpenSSL::PKCS5.pbkdf2_hmac(
        fp[:fingerprint],
        salt,
        10000,
        32,
        OpenSSL::Digest::SHA256.new
      )
    end
  end
end
```

#### 3. Server-side binding:
```typescript
// server/app/api/licenses/activate/route.ts
export const POST = async (request) => {
  const { license_key, user_email, system_fingerprint } = await request.json();
  
  // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ¸ Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ²Ğ¶Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ½Ğ° Ñ–Ğ½ÑˆÑ–Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ–
  const { data: existing } = await supabase
    .from('system_infos')
    .select('fingerprint_hash')
    .eq('license_id', license.id)
    .single();
  
  if (existing && existing.fingerprint_hash !== system_fingerprint) {
    return apiError(
      'Ğ›Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ²Ğ¶Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ½Ğ° Ñ–Ğ½ÑˆÑ–Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ–. Ğ”ĞµĞ°ĞºÑ‚Ğ¸Ğ²ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ñ–Ñ.',
      403
    );
  }
  
  // Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ binding
  await supabase
    .from('system_infos')
    .upsert({
      license_id: license.id,
      fingerprint_hash: system_fingerprint,
      bound_at: new Date().toISOString()
    });
};
```

### âœ… ĞŸĞµÑ€ĞµĞ²Ğ°Ğ³Ğ¸:
- â­â­â­â­â­ **Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚Ñƒ Ñ‚Ğ° UX**
- ĞŸÑ€Ğ°Ñ†ÑÑ” offline (grace period)
- Hardware binding (Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° ĞºĞ¾Ğ¿Ñ–ÑĞ²Ğ°Ñ‚Ğ¸)
- Server-side control
- Ğ—Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ– Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ– Ğ´Ğ°Ğ½Ñ–

### âŒ ĞĞµĞ´Ğ¾Ğ»Ñ–ĞºĞ¸:
- ĞŸÑ–ÑĞ»Ñ 7 Ğ´Ğ½Ñ–Ğ² offline Ğ¿Ğ¾Ñ‚Ñ€Ñ–Ğ±ĞµĞ½ internet
- Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑˆĞ° Ñ€ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ
- ĞŸĞ¾Ñ‚Ñ€ĞµĞ±ÑƒÑ” encryption

### ğŸ“Š ĞÑ†Ñ–Ğ½ĞºĞ¸:
- **Ğ—Ğ°Ñ…Ğ¸ÑÑ‚:** 8/10 ğŸŸ¢
- **UX:** 9/10 ğŸŸ¢
- **Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ:** 8/10 ğŸŸ¡
- **ĞĞ°Ğ´Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ:** 9/10 ğŸŸ¢

**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ñ–Ñ:** â­â­â­â­â­ **ĞĞĞ™ĞšĞ ĞĞ©Ğ˜Ğ™ Ğ’ĞĞ Ğ†ĞĞĞ¢**

---

## ğŸ† Ğ’ĞĞ Ğ†ĞĞĞ¢ 3: TIME-BASED TOKENS + SERVER VALIDATION

### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ñ–Ñ: "Short-lived tokens Ğ· periodic renewal"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. ACTIVATION                       â”‚
â”‚     â”œâ”€ Get license from server      â”‚
â”‚     â”œâ”€ Receive 7-day token          â”‚
â”‚     â””â”€ Store encrypted locally      â”‚
â”‚                                      â”‚
â”‚  2. RUNTIME                          â”‚
â”‚     â”œâ”€ Check token validity         â”‚
â”‚     â”œâ”€ If < 24h left â†’ auto-renew   â”‚
â”‚     â””â”€ Block if token expired       â”‚
â”‚                                      â”‚
â”‚  3. TOKEN RENEWAL                    â”‚
â”‚     â”œâ”€ Background every 24h         â”‚
â”‚     â”œâ”€ Get new 7-day token          â”‚
â”‚     â””â”€ Seamless Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ:

```ruby
module ProGran3::Security
  class TokenBasedManager
    TOKEN_LIFETIME = 7 * 24 * 60 * 60 # 7 days
    RENEWAL_THRESHOLD = 24 * 60 * 60  # Renew if < 24h left
    
    def validate_token
      token = load_current_token
      
      # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ¸ Ñ‚Ğ¾ĞºĞµĞ½ Ñ–ÑĞ½ÑƒÑ”
      return requires_activation unless token
      
      # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° fingerprint
      current_fp = HardwareFingerprint.generate[:fingerprint]
      if token[:fingerprint] != current_fp
        return { valid: false, error: 'Hardware mismatch' }
      end
      
      # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° expiration
      expires_at = Time.parse(token[:expires_at])
      now = Time.now
      
      if expires_at < now
        # Token expired - Ğ¿Ğ¾Ñ‚Ñ€Ñ–Ğ±ĞµĞ½ Ğ½Ğ¾Ğ²Ğ¸Ğ¹
        return renew_token_required
      elsif (expires_at - now) < RENEWAL_THRESHOLD
        # Token ÑĞºĞ¾Ñ€Ğ¾ Ğ·Ğ°ĞºÑ–Ğ½Ñ‡Ğ¸Ñ‚ÑŒÑÑ - auto-renew Ğ² background
        renew_token_background(token)
      end
      
      # Token Ğ²Ğ°Ğ»Ñ–Ğ´Ğ½Ğ¸Ğ¹
      { valid: true, expires_in: (expires_at - now).to_i }
    end
    
    def activate_license(email, license_key)
      fingerprint = HardwareFingerprint.generate[:fingerprint]
      
      # Server activation
      result = ApiClient.activate(email, license_key, fingerprint)
      
      if result[:success]
        # ĞÑ‚Ñ€Ğ¸Ğ¼ÑƒÑ”Ğ¼Ğ¾ 7-Ğ´ĞµĞ½Ğ½Ğ¸Ğ¹ token
        token = {
          license_key: license_key,
          fingerprint: fingerprint,
          issued_at: Time.now.iso8601,
          expires_at: (Time.now + TOKEN_LIFETIME).iso8601,
          server_signature: result[:signature]
        }
        
        save_token(token)
        return { success: true }
      else
        return result
      end
    end
    
    private
    
    def renew_token_background(old_token)
      Thread.new do
        result = ApiClient.renew_token(old_token[:license_key])
        
        if result[:success]
          new_token = old_token.merge({
            expires_at: (Time.now + TOKEN_LIFETIME).iso8601,
            server_signature: result[:signature],
            renewed_at: Time.now.iso8601
          })
          
          save_token(new_token)
          Logger.success("Token renewed successfully", "License")
        else
          Logger.warn("Token renewal failed: #{result[:error]}", "License")
        end
      end
    end
    
    def renew_token_required
      # Synchronous renewal (Ğ±Ğ»Ğ¾ĞºÑƒÑ” Ğ·Ğ°Ğ¿ÑƒÑĞº)
      token = load_current_token
      result = ApiClient.renew_token(token[:license_key])
      
      if result[:success]
        new_token = {
          expires_at: (Time.now + TOKEN_LIFETIME).iso8601,
          server_signature: result[:signature]
        }.merge(token)
        
        save_token(new_token)
        return { valid: true }
      else
        return { valid: false, error: 'Token renewal failed' }
      end
    end
  end
end
```

### Server-side:
```typescript
// POST /api/licenses/renew-token
export const POST = withPublicApi(async ({ supabase, request }) => {
  const { license_key, fingerprint } = await request.json();
  
  // Verify license is active
  const { data: license } = await supabase
    .from('licenses')
    .select('*, system_infos(*)')
    .eq('license_key', license_key)
    .eq('status', 'active')
    .single();
  
  if (!license) {
    return apiError('Invalid or inactive license', 403);
  }
  
  // Verify fingerprint match
  if (license.system_infos.fingerprint_hash !== fingerprint) {
    return apiError('Hardware mismatch', 403);
  }
  
  // Generate new token signature
  const token = {
    license_key,
    fingerprint,
    expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  };
  
  const signature = crypto
    .createHmac('sha256', process.env.CRYPTO_SECRET_KEY!)
    .update(JSON.stringify(token))
    .digest('hex');
  
  return apiSuccess({
    token,
    signature,
    expires_at: token.expires_at
  });
});
```

### âœ… ĞŸĞµÑ€ĞµĞ²Ğ°Ğ³Ğ¸:
- â­â­â­â­â­ **Ğ’Ñ–Ğ´Ğ¼Ñ–Ğ½Ğ½Ğ¸Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚Ñƒ Ñ‚Ğ° UX**
- ĞŸÑ€Ğ°Ñ†ÑÑ” offline Ğ´Ğ¾ 7 Ğ´Ğ½Ñ–Ğ²
- Auto-renewal (ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡ Ğ½Ğµ Ğ¿Ğ¾Ğ¼Ñ–Ñ‡Ğ°Ñ”)
- Hardware binding
- Short-lived tokens (Ğ¼ĞµĞ½ÑˆĞ° Ğ²Ğ°Ñ€Ñ‚Ñ–ÑÑ‚ÑŒ ĞºĞ¾Ğ¼Ğ¿Ñ€Ğ¾Ğ¼ĞµÑ‚Ğ°Ñ†Ñ–Ñ—)

### âŒ ĞĞµĞ´Ğ¾Ğ»Ñ–ĞºĞ¸:
- ĞŸĞ¾Ñ‚Ñ€ĞµĞ±ÑƒÑ” Ñ–Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚ Ñ€Ğ°Ğ· Ğ½Ğ° Ñ‚Ğ¸Ğ¶Ğ´ĞµĞ½ÑŒ
- Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑˆĞ° Ğ»Ğ¾Ğ³Ñ–ĞºĞ°

### ğŸ“Š ĞÑ†Ñ–Ğ½ĞºĞ¸:
- **Ğ—Ğ°Ñ…Ğ¸ÑÑ‚:** 8/10 ğŸŸ¢
- **UX:** 10/10 ğŸŸ¢
- **Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ:** 7/10 ğŸŸ¡
- **ĞĞ°Ğ´Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ:** 10/10 ğŸŸ¢

**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ñ–Ñ:** â­â­â­â­â­ **Ğ†Ğ”Ğ•ĞĞ›Ğ¬ĞĞ˜Ğ™ Ğ‘ĞĞ›ĞĞĞ¡**

---

## ğŸ† Ğ’ĞĞ Ğ†ĞĞĞ¢ 4: CODE OBFUSCATION + ENCRYPTION

### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ñ–Ñ: "Ğ—Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ ĞºĞ¾Ğ´ + Runtime decryption"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. DISTRIBUTION                     â”‚
â”‚     â”œâ”€ Core ĞºĞ¾Ğ´ Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹        â”‚
â”‚     â”œâ”€ Decryption key Ğ²Ñ–Ğ´ ÑĞµÑ€Ğ²ĞµÑ€Ğ°   â”‚
â”‚     â””â”€ Runtime Ğ´ĞµĞºÑ€Ğ¸Ğ¿Ñ†Ñ–Ñ             â”‚
â”‚                                      â”‚
â”‚  2. RUNTIME                          â”‚
â”‚     â”œâ”€ Validate license online      â”‚
â”‚     â”œâ”€ Get decryption key           â”‚
â”‚     â”œâ”€ Decrypt core modules         â”‚
â”‚     â””â”€ Load decrypted code          â”‚
â”‚                                      â”‚
â”‚  3. PROTECTION                       â”‚
â”‚     â”œâ”€ No valid license = no key    â”‚
â”‚     â”œâ”€ Can't read encrypted code    â”‚
â”‚     â””â”€ Can't run without server     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ:

#### 1. Code Encryption (Build step):
```ruby
# scripts/encrypt_plugin.rb
require 'openssl'
require 'base64'

module PluginEncryptor
  def self.encrypt_file(source_path, output_path, key)
    cipher = OpenSSL::Cipher.new('AES-256-CBC')
    cipher.encrypt
    cipher.key = Digest::SHA256.digest(key)
    iv = cipher.random_iv
    
    source_code = File.read(source_path)
    encrypted = cipher.update(source_code) + cipher.final
    
    # Save IV + encrypted
    File.write(output_path, Base64.strict_encode64(iv + encrypted))
  end
  
  def self.encrypt_core_modules
    key = ENV['PLUGIN_ENCRYPTION_KEY']
    
    core_files = [
      'builders/foundation_builder.rb',
      'builders/tiling_builder.rb',
      'builders/cladding_builder.rb',
      # ... Ñ–Ğ½ÑˆÑ– ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ñ– Ñ„Ğ°Ğ¹Ğ»Ğ¸
    ]
    
    core_files.each do |file|
      source = File.join('plugin/proGran3', file)
      output = source.gsub('.rb', '.enc')
      
      encrypt_file(source, output, key)
      File.delete(source) # Ğ’Ğ¸Ğ´Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¾Ñ€Ğ¸Ğ³Ñ–Ğ½Ğ°Ğ»
    end
  end
end
```

#### 2. Runtime Decryption:
```ruby
module ProGran3::Security
  class CodeLoader
    def self.load_encrypted_module(module_path)
      # ĞÑ‚Ñ€Ğ¸Ğ¼ÑƒÑ”Ğ¼Ğ¾ decryption key Ğ²Ñ–Ğ´ ÑĞµÑ€Ğ²ĞµÑ€Ğ°
      key = get_decryption_key_from_server
      
      return false unless key
      
      # Ğ”ĞµĞºÑ€Ğ¸Ğ¿Ñ‚ÑƒÑ”Ğ¼Ğ¾ Ñ‚Ğ° Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ÑƒÑ”Ğ¼Ğ¾
      encrypted_path = module_path.gsub('.rb', '.enc')
      encrypted = File.read(encrypted_path)
      
      decrypted_code = decrypt_code(encrypted, key)
      
      # Ğ’Ğ¸ĞºĞ¾Ğ½ÑƒÑ”Ğ¼Ğ¾ Ğ´ĞµĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ ĞºĞ¾Ğ´
      eval(decrypted_code, TOPLEVEL_BINDING, module_path)
      
      true
    rescue => e
      Logger.error("Failed to load encrypted module: #{e.message}", "CodeLoader")
      false
    end
    
    private
    
    def self.get_decryption_key_from_server
      # Ğ¢Ñ–Ğ»ÑŒĞºĞ¸ Ğ²Ğ°Ğ»Ñ–Ğ´Ğ½Ñ– Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ— Ğ¾Ñ‚Ñ€Ğ¸Ğ¼ÑƒÑÑ‚ÑŒ ĞºĞ»ÑÑ‡
      license = LicenseStorage.load
      return nil unless license
      
      result = ApiClient.request_decryption_key(license[:license_key])
      result[:success] ? result[:decryption_key] : nil
    end
    
    def self.decrypt_code(encrypted_data, key)
      cipher = OpenSSL::Cipher.new('AES-256-CBC')
      cipher.decrypt
      cipher.key = Digest::SHA256.digest(key)
      
      decoded = Base64.strict_decode64(encrypted_data)
      iv = decoded[0...16]
      encrypted = decoded[16..-1]
      
      cipher.iv = iv
      cipher.update(encrypted) + cipher.final
    end
  end
end
```

#### 3. Server endpoint Ğ´Ğ»Ñ ĞºĞ»ÑÑ‡Ñ–Ğ²:
```typescript
// POST /api/licenses/decryption-key
export const POST = withPublicApi(async ({ supabase, request }) => {
  const { license_key, fingerprint, signature } = await request.json();
  
  // Verify HMAC signature
  if (!verifyHMAC(license_key + fingerprint, signature)) {
    return apiError('Invalid signature', 403);
  }
  
  // Check license validity
  const { data: license } = await supabase
    .from('licenses')
    .select('*, system_infos(*)')
    .eq('license_key', license_key)
    .eq('status', 'active')
    .single();
  
  if (!license) {
    return apiError('Invalid license', 404);
  }
  
  // Verify fingerprint
  if (license.system_infos.fingerprint_hash !== fingerprint) {
    return apiError('Hardware mismatch', 403);
  }
  
  // Generate short-lived decryption key (valid 24h)
  const decryptionKey = crypto
    .createHmac('sha256', process.env.CRYPTO_SECRET_KEY!)
    .update(`${license_key}:${fingerprint}:${Date.now()}`)
    .digest('hex');
  
  return apiSuccess({
    decryption_key: decryptionKey,
    expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000)
  });
});
```

### âœ… ĞŸĞµÑ€ĞµĞ²Ğ°Ğ³Ğ¸:
- â­â­â­â­â­ **ĞĞ°Ğ¹Ğ²Ğ¸Ñ‰Ğ¸Ğ¹ Ñ€Ñ–Ğ²ĞµĞ½ÑŒ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚Ñƒ**
- ĞĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¾ Ğ·Ñ‡Ğ¸Ñ‚Ğ°Ñ‚Ğ¸ ĞºĞ¾Ğ´ Ğ±ĞµĞ· Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ—
- ĞĞ°Ğ²Ñ–Ñ‚ÑŒ Ğ· Ñ„Ğ°Ğ¹Ğ»Ğ°Ğ¼Ğ¸ - Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğ¸
- Server Ğ¼Ğ°Ñ” Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ğ¹ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒ

### âŒ ĞĞµĞ´Ğ¾Ğ»Ñ–ĞºĞ¸:
- Ğ’Ğ¸Ğ¼Ğ°Ğ³Ğ°Ñ” internet Ğ¿Ñ€Ğ¸ ĞšĞĞ–ĞĞĞœĞ£ Ğ·Ğ°Ğ¿ÑƒÑĞºÑƒ
- Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ğ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°
- Overhead Ğ½Ğ° Ğ´ĞµĞºÑ€Ğ¸Ğ¿Ñ†Ñ–Ñ (~100-200ms)
- Ğ Ğ¸Ğ·Ğ¸Ğº: ÑĞºÑ‰Ğ¾ ÑĞµÑ€Ğ²ĞµÑ€ down = Ğ¿Ğ»Ğ°Ğ³Ñ–Ğ½ Ğ½Ğµ Ğ¿Ñ€Ğ°Ñ†ÑÑ”

### ğŸ“Š ĞÑ†Ñ–Ğ½ĞºĞ¸:
- **Ğ—Ğ°Ñ…Ğ¸ÑÑ‚:** 10/10 ğŸŸ¢
- **UX:** 4/10 ğŸ”´
- **Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ:** 9/10 ğŸ”´
- **ĞĞ°Ğ´Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ:** 5/10 ğŸ”´

**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ñ–Ñ:** Ğ¢Ñ–Ğ»ÑŒĞºĞ¸ Ğ´Ğ»Ñ high-value products ($1000+)

---

## ğŸ† Ğ’ĞĞ Ğ†ĞĞĞ¢ 5: HYBRID - MULTI-LAYER PROTECTION

### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ñ–Ñ: "ĞšĞ¾Ğ¼Ğ±Ñ–Ğ½Ğ°Ñ†Ñ–Ñ Ğ´ĞµĞºÑ–Ğ»ÑŒĞºĞ¾Ñ… Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ–Ğ²"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAYER 1: Hardware Fingerprint       â”‚
â”‚  â””â”€ ĞŸÑ€Ğ¸Ğ²'ÑĞ·ĞºĞ° Ğ´Ğ¾ motherboard + CPU   â”‚
â”‚                                      â”‚
â”‚  LAYER 2: Time-based Tokens          â”‚
â”‚  â””â”€ 7-day tokens Ğ· auto-renewal     â”‚
â”‚                                      â”‚
â”‚  LAYER 3: Periodic Online Check      â”‚
â”‚  â””â”€ Online validation Ñ€Ğ°Ğ· Ğ½Ğ° 48h    â”‚
â”‚                                      â”‚
â”‚  LAYER 4: Critical Features Lock     â”‚
â”‚  â””â”€ Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ— Ğ²Ğ¸Ğ¼Ğ°Ğ³Ğ°ÑÑ‚ÑŒ onlineâ”‚
â”‚                                      â”‚
â”‚  LAYER 5: Usage Analytics            â”‚
â”‚  â””â”€ Ğ’Ğ¸ÑĞ²Ğ»ĞµĞ½Ğ½Ñ Ğ°Ğ½Ğ¾Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ñ— Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ñ– â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ:

```ruby
module ProGran3::Security
  class HybridLicenseManager
    def initialize
      @hardware_checker = HardwareFingerprint
      @token_manager = TokenManager.new
      @usage_tracker = UsageTracker.new
    end
    
    def validate_for_startup
      # Layer 1: Hardware check
      fp = @hardware_checker.generate
      stored_fp = load_stored_fingerprint
      
      if stored_fp && fp[:fingerprint] != stored_fp
        return hardware_mismatch_error
      end
      
      # Layer 2: Token check
      token = @token_manager.get_current_token
      
      if !token || @token_manager.expired?(token)
        return token_renewal_required
      end
      
      # Layer 3: Periodic online (async)
      schedule_online_validation if needs_online_check?
      
      # All OK
      { valid: true, mode: 'offline' }
    end
    
    def validate_for_critical_feature(feature_name)
      # Critical features Ğ—ĞĞ’Ğ–Ğ”Ğ˜ Ğ²Ğ¸Ğ¼Ğ°Ğ³Ğ°ÑÑ‚ÑŒ online
      result = ApiClient.validate_feature_access(feature_name)
      
      if result[:success]
        @usage_tracker.track(feature_name)
        { valid: true }
      else
        { 
          valid: false, 
          error: 'online_required',
          message: 'Ğ¦Ñ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ Ğ²Ğ¸Ğ¼Ğ°Ğ³Ğ°Ñ” Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ´Ğ¾ Ñ–Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚Ñƒ'
        }
      end
    end
    
    def check_usage_anomaly
      usage = @usage_tracker.get_statistics
      
      # Ğ’Ğ¸ÑĞ²Ğ»ĞµĞ½Ğ½Ñ Ğ¿Ñ–Ğ´Ğ¾Ğ·Ñ€Ñ–Ğ»Ğ¾Ñ— Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ñ–
      if usage[:requests_per_hour] > 1000
        Logger.warn("Anomaly detected: High usage rate", "Security")
        report_to_server('high_usage_rate', usage)
      end
      
      if usage[:unique_ips] > 5
        Logger.warn("Anomaly detected: Multiple IPs", "Security")
        report_to_server('multiple_ips', usage)
      end
    end
  end
end
```

### Feature-level protection:
```ruby
# builders/foundation_builder.rb
module ProGran3
  class FoundationBuilder
    def self.add_foundation(depth, width, height)
      # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ´Ğ»Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ñ… Ñ„ÑƒĞ½ĞºÑ†Ñ–Ğ¹
      validation = $license_manager.validate_for_critical_feature('foundation')
      
      unless validation[:valid]
        UI.messagebox(validation[:message])
        return false
      end
      
      # ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ²Ğ¶ÑƒÑ”Ğ¼Ğ¾ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ñƒ Ñ€Ğ¾Ğ±Ğ¾Ñ‚Ñƒ
      create_foundation_geometry(depth, width, height)
    end
  end
end
```

### âœ… ĞŸĞµÑ€ĞµĞ²Ğ°Ğ³Ğ¸:
- â­â­â­â­â­ **ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚**
- Multi-layer defence
- Ğ’Ğ¸ÑĞ²Ğ»ĞµĞ½Ğ½Ñ Ğ°Ğ½Ğ¾Ğ¼Ğ°Ğ»Ñ–Ğ¹
- Ğ“Ğ½ÑƒÑ‡ĞºĞ¸Ğ¹ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒ (per-feature)
- Analytics Ğ´Ğ»Ñ Ğ±Ñ–Ğ·Ğ½ĞµÑÑƒ

### âŒ ĞĞµĞ´Ğ¾Ğ»Ñ–ĞºĞ¸:
- ĞĞ°Ğ¹ÑĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑˆĞ° Ñ€ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ
- Overhead Ğ½Ğ° ĞºĞ¾Ğ¶Ğ½Ñƒ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ
- ĞŸĞ¾Ñ‚Ñ€ĞµĞ±ÑƒÑ” server Ğ´Ğ»Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ñ… Ñ„ÑƒĞ½ĞºÑ†Ñ–Ğ¹

### ğŸ“Š ĞÑ†Ñ–Ğ½ĞºĞ¸:
- **Ğ—Ğ°Ñ…Ğ¸ÑÑ‚:** 10/10 ğŸŸ¢
- **UX:** 7/10 ğŸŸ¡
- **Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ:** 10/10 ğŸ”´
- **ĞĞ°Ğ´Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ:** 8/10 ğŸŸ¢

**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ñ–Ñ:** Ğ”Ğ»Ñ enterprise Ğ· high piracy risk

---

## ğŸ† Ğ’ĞĞ Ğ†ĞĞĞ¢ 5: SIMPLE ACTIVATION + HEARTBEAT

### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ñ–Ñ: "ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Ñ– ĞµÑ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. ACTIVATION (ONE-TIME)            â”‚
â”‚     â”œâ”€ Email + License Key          â”‚
â”‚     â”œâ”€ Hardware Fingerprint          â”‚
â”‚     â””â”€ Save locally (encrypted)      â”‚
â”‚                                      â”‚
â”‚  2. STARTUP                          â”‚
â”‚     â”œâ”€ Check local license file     â”‚
â”‚     â”œâ”€ Verify fingerprint match     â”‚
â”‚     â””â”€ Start immediately             â”‚
â”‚                                      â”‚
â”‚  3. HEARTBEAT (BACKGROUND)           â”‚
â”‚     â”œâ”€ Every 5 minutes              â”‚
â”‚     â”œâ”€ Update last_seen             â”‚
â”‚     â””â”€ Server can revoke remotely   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ:

```ruby
module ProGran3::Security
  class SimpleLicenseManager
    LICENSE_FILE = File.join(Dir.home, '.progran3_license')
    
    def validate
      license = load_license
      
      # ĞĞµĞ¼Ğ°Ñ” Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ—
      return { valid: false, action: 'activate' } unless license
      
      # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° fingerprint
      current_fp = generate_fingerprint
      if license['fingerprint'] != current_fp
        return { 
          valid: false, 
          error: 'Ğ›Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ¿Ñ€Ğ¸Ğ²\'ÑĞ·Ğ°Ğ½Ğ° Ğ´Ğ¾ Ñ–Ğ½ÑˆĞ¾Ğ³Ğ¾ ĞºĞ¾Ğ¼Ğ¿\'ÑÑ‚ĞµÑ€Ğ°' 
        }
      end
      
      # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° expiration
      if license['expires_at']
        expires = Time.parse(license['expires_at'])
        if expires < Time.now
          return { valid: false, error: 'Ğ›Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ¾Ñ‡ĞµĞ½Ğ°' }
        end
      end
      
      # Ğ’ÑĞµ OK
      { valid: true, license: license }
    end
    
    def activate(email, license_key)
      fingerprint = generate_fingerprint
      
      # API call
      result = ApiClient.activate(email, license_key, fingerprint)
      
      if result[:success]
        # Save locally
        File.write(LICENSE_FILE, result[:data].to_json)
        
        # Hide file
        system("attrib +h \"#{LICENSE_FILE}\"") if RUBY_PLATFORM.include?('mingw')
        
        # Start heartbeat
        start_heartbeat(license_key, fingerprint)
        
        return { success: true }
      else
        return result
      end
    end
    
    def start_heartbeat(key, fingerprint)
      # Background thread
      Thread.new do
        loop do
          sleep(5 * 60) # 5 minutes
          
          result = ApiClient.heartbeat(key, fingerprint)
          
          if !result[:success] && !result[:offline]
            # License revoked or expired
            Logger.warn("License no longer valid", "Heartbeat")
            # Can show warning to user
          end
        end
      end
    end
    
    private
    
    def generate_fingerprint
      require 'digest'
      
      data = {
        mb: `wmic baseboard get serialnumber`.scan(/\w{8,}/).first,
        cpu: `wmic cpu get processorid`.scan(/\w{8,}/).first,
        hostname: Socket.gethostname
      }
      
      Digest::SHA256.hexdigest(data.to_json)
    end
    
    def load_license
      return nil unless File.exist?(LICENSE_FILE)
      JSON.parse(File.read(LICENSE_FILE))
    rescue
      nil
    end
  end
end
```

### âœ… ĞŸĞµÑ€ĞµĞ²Ğ°Ğ³Ğ¸:
- â­â­â­â­ **ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Ñ– Ğ½Ğ°Ğ´Ñ–Ğ¹Ğ½Ğ¾**
- Easy implementation (3 Ğ´Ğ½Ñ–)
- ĞŸÑ€Ğ°Ñ†ÑÑ” offline Ğ¿Ğ¾Ğ²Ğ½Ñ–ÑÑ‚Ñ
- Hardware binding
- Remote revocation Ğ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¸Ğ¹

### âŒ ĞĞµĞ´Ğ¾Ğ»Ñ–ĞºĞ¸:
- ĞœĞ¾Ğ¶Ğ½Ğ° Ğ¾Ğ±Ñ–Ğ¹Ñ‚Ğ¸ ÑĞºÑ‰Ğ¾ Ğ²Ñ–Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğ¸ heartbeat ĞºĞ¾Ğ´
- Ğ”Ğ¾Ğ²Ñ–Ñ€Ğ° Ğ´Ğ¾ local storage
- ĞĞµĞ¼Ğ°Ñ” Ğ¾Ğ±Ñ„ÑƒÑĞºĞ°Ñ†Ñ–Ñ—

### ğŸ“Š ĞÑ†Ñ–Ğ½ĞºĞ¸:
- **Ğ—Ğ°Ñ…Ğ¸ÑÑ‚:** 6/10 ğŸŸ¡
- **UX:** 10/10 ğŸŸ¢
- **Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ:** 4/10 ğŸŸ¢
- **ĞĞ°Ğ´Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ:** 9/10 ğŸŸ¢

**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ñ–Ñ:** â­â­â­â­ **Ğ”Ğ»Ñ MVP Ñ‚Ğ° ÑˆĞ²Ğ¸Ğ´ĞºĞ¾Ğ³Ğ¾ ÑÑ‚Ğ°Ñ€Ñ‚Ñƒ**

---

## ğŸ“Š ĞŸĞĞ Ğ†Ğ’ĞĞ¯Ğ›Ğ¬ĞĞ Ğ¢ĞĞ‘Ğ›Ğ˜Ğ¦Ğ¯

| Ğ’Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚ | Ğ—Ğ°Ñ…Ğ¸ÑÑ‚ | UX | Ğ¡ĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚ÑŒ | ĞĞ°Ğ´Ñ–Ğ¹Ğ½Ñ–ÑÑ‚ÑŒ | Ğ§Ğ°Ñ Ğ²Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ´Ğ¶ĞµĞ½Ğ½Ñ | Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ |
|---------|--------|----|-----------:|------------|------------------|---------|
| **1. Hardware + Always Online** | 9/10 | 5/10 | 7/10 | 6/10 | 2 Ñ‚Ğ¸Ğ¶Ğ½Ñ– | â­â­â­ |
| **2. Offline First + Grace Period** | 8/10 | 9/10 | 8/10 | 9/10 | 2-3 Ñ‚Ğ¸Ğ¶Ğ½Ñ– | â­â­â­â­â­ |
| **3. Time-based Tokens** | 8/10 | 10/10 | 7/10 | 10/10 | 2 Ñ‚Ğ¸Ğ¶Ğ½Ñ– | â­â­â­â­â­ |
| **4. Code Encryption** | 10/10 | 4/10 | 9/10 | 5/10 | 3-4 Ñ‚Ğ¸Ğ¶Ğ½Ñ– | â­â­â­ |
| **5. Simple + Heartbeat** | 6/10 | 10/10 | 4/10 | 9/10 | 3 Ğ´Ğ½Ñ– | â­â­â­â­ |

---

## ğŸ¯ Ğ”Ğ•Ğ¢ĞĞ›Ğ¬ĞĞ• ĞŸĞĞ Ğ†Ğ’ĞĞ¯ĞĞĞ¯

### Ğ—Ğ° Ğ·Ğ°Ñ…Ğ¸ÑÑ‚Ğ¾Ğ¼ Ğ²Ñ–Ğ´ ĞºÑ€Ğ°Ğ´Ñ–Ğ¶ĞºĞ¸:

```
Code Encryption:           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  10/10  (Ğ½ĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¾ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğ¸ Ğ±ĞµĞ· ĞºĞ»ÑÑ‡Ğ°)
Hardware + Always Online:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘   9/10  (Ğ¿Ğ¾Ñ‚Ñ€Ñ–Ğ±ĞµĞ½ internet Ğ·Ğ°Ğ²Ğ¶Ğ´Ğ¸)
Offline First + Grace:     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘   8/10  (7 Ğ´Ğ½Ñ–Ğ² offline)
Time-based Tokens:         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘   8/10  (tokens Ğ¼Ğ¾Ğ¶Ğ½Ğ° ÑƒĞºÑ€Ğ°ÑÑ‚Ğ¸)
Simple + Heartbeat:        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘   6/10  (Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ¾Ğ±Ñ–Ğ¹Ñ‚Ğ¸)
```

### Ğ—Ğ° UX (Ğ·Ñ€ÑƒÑ‡Ğ½Ñ–ÑÑ‚ÑŒ):

```
Simple + Heartbeat:        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  10/10  (Ğ½Ğµ Ğ·Ğ°Ğ²Ğ°Ğ¶Ğ°Ñ”)
Time-based Tokens:         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  10/10  (auto-renewal)
Offline First + Grace:     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘   9/10  (7 Ğ´Ğ½Ñ–Ğ² offline OK)
Hardware + Always Online:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘   5/10  (Ğ¿Ğ¾Ñ‚Ñ€Ñ–Ğ±ĞµĞ½ internet)
Code Encryption:           â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘   4/10  (online required)
```

### Ğ—Ğ° ÑĞºĞ»Ğ°Ğ´Ğ½Ñ–ÑÑ‚Ñ Ñ€ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ—:

```
Simple + Heartbeat:        â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘   4/10  (3 Ğ´Ğ½Ñ–)
Time-based Tokens:         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘   7/10  (2 Ñ‚Ğ¸Ğ¶Ğ½Ñ–)
Hardware + Always Online:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘   7/10  (2 Ñ‚Ğ¸Ğ¶Ğ½Ñ–)
Offline First + Grace:     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘   8/10  (2-3 Ñ‚Ğ¸Ğ¶Ğ½Ñ–)
Code Encryption:           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘   9/10  (3-4 Ñ‚Ğ¸Ğ¶Ğ½Ñ–)
```

---

## ğŸ’¡ Ğ Ğ•ĞšĞĞœĞ•ĞĞ”ĞĞ¦Ğ†Ğ‡ ĞŸĞ Ğ¡Ğ¦Ğ•ĞĞĞ Ğ†Ğ¯Ğœ

### Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ñ–Ğ¹ A: Ğ¨Ğ²Ğ¸Ğ´ĞºĞ¸Ğ¹ Ğ²Ğ¸Ñ…Ñ–Ğ´ Ğ½Ğ° Ñ€Ğ¸Ğ½Ğ¾Ğº (MVP)
**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒÑ:** Ğ’Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚ 5 (Simple + Heartbeat)

**Ğ§Ğ¾Ğ¼Ñƒ:**
- âœ… 3 Ğ´Ğ½Ñ– Ñ€Ğ¾Ğ·Ñ€Ğ¾Ğ±ĞºĞ¸
- âœ… ĞŸÑ€Ğ¾ÑÑ‚Ğ¸Ğ¹ Ñƒ Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼Ñ†Ñ–
- âœ… Ğ’Ñ–Ğ´Ğ¼Ñ–Ğ½Ğ½Ğ¸Ğ¹ UX
- âœ… Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¸Ğ¹ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚ (6/10)

**Ğ”Ğ¾ÑÑ‚Ğ°Ñ‚Ğ½ÑŒĞ¾ Ğ´Ğ»Ñ:** ĞŸĞµÑ€ÑˆÑ– 6 Ğ¼Ñ–ÑÑÑ†Ñ–Ğ², Ñ‚ĞµÑÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ€Ğ¸Ğ½ĞºÑƒ

---

### Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ñ–Ğ¹ B: Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚Ñƒ Ñ‚Ğ° UX (Ğ Ğ•ĞšĞĞœĞ•ĞĞ”Ğ£Ğ®!)
**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒÑ:** Ğ’Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚ 2 (Offline First + Grace Period)

**Ğ§Ğ¾Ğ¼Ñƒ:**
- âœ… Ğ’Ğ¸ÑĞ¾ĞºĞ¸Ğ¹ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚ (8/10)
- âœ… Ğ§ÑƒĞ´Ğ¾Ğ²Ğ¸Ğ¹ UX (9/10)
- âœ… ĞŸÑ€Ğ°Ñ†ÑÑ” offline
- âœ… Server control

**Ğ†Ğ´ĞµĞ°Ğ»ÑŒĞ½Ğ¾ Ğ´Ğ»Ñ:** Ğ‘Ñ–Ğ»ÑŒÑˆÑ–ÑÑ‚ÑŒ SaaS products

---

### Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ñ–Ğ¹ C: ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚
**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒÑ:** Ğ’Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚ 4 (Code Encryption) + Ğ’Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚ 2

**Ğ§Ğ¾Ğ¼Ñƒ:**
- âœ… ĞĞ°Ğ¹Ğ²Ğ¸Ñ‰Ğ¸Ğ¹ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚ (10/10)
- âœ… Multi-layer defense
- âœ… ĞĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¾ Ğ¾Ğ±Ñ–Ğ¹Ñ‚Ğ¸

**Ğ”Ğ»Ñ:** High-value products, enterprise

---

### Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ñ–Ğ¹ D: Enterprise ĞºĞ»Ñ–Ñ”Ğ½Ñ‚Ğ¸
**Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒÑ:** Ğ’Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚ 4 (Hybrid Multi-layer)

**Ğ§Ğ¾Ğ¼Ñƒ:**
- âœ… Per-feature control
- âœ… Usage analytics
- âœ… Anomaly detection
- âœ… Maximum control

**Ğ”Ğ»Ñ:** Enterprise Ğ»Ñ–Ñ†ĞµĞ½Ğ·Ñ–Ñ— $5000+

---

## ğŸš€ ĞŸĞĞ•Ğ¢ĞĞŸĞĞ• Ğ’ĞŸĞ ĞĞ’ĞĞ”Ğ–Ğ•ĞĞĞ¯

### Phase 1 (Week 1-2): Simple + Heartbeat
```ruby
âœ… Hardware fingerprinting
âœ… Activation API
âœ… Local storage
âœ… Basic heartbeat
```
**Result:** Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¸Ğ¹ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚ Ğ¿Ñ€Ğ°Ñ†ÑÑ”

---

### Phase 2 (Week 3-4): Add Grace Period
```ruby
âœ… Encrypted storage
âœ… Grace period logic
âœ… Background validation
âœ… Token renewal
```
**Result:** Offline support + ĞºÑ€Ğ°Ñ‰Ğ¸Ğ¹ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚

---

### Phase 3 (Week 5-6): Add Analytics
```ruby
âœ… Usage tracking
âœ… Anomaly detection
âœ… Per-feature validation
âœ… Admin dashboard integration
```
**Result:** Enterprise-grade ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°

---

### Phase 4 (Optional): Code Encryption
```ruby
âœ… Build-time encryption
âœ… Runtime decryption
âœ… Key management
âœ… Rollout strategy
```
**Result:** Maximum protection

---

## ğŸ”’ Ğ”ĞĞ”ĞĞ¢ĞšĞĞ’Ğ† Ğ—ĞĞ¥Ğ˜Ğ¡Ğ¢Ğ˜

### 1. Time Manipulation Protection
```ruby
def detect_time_manipulation
  # Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ last known time
  last_time = load_last_known_time
  current_time = Time.now
  
  if last_time && current_time < last_time
    # Ğ§Ğ°Ñ Ğ¿Ñ–ÑˆĞ¾Ğ² Ğ½Ğ°Ğ·Ğ°Ğ´ = Ğ¼Ğ°Ğ½Ñ–Ğ¿ÑƒĞ»ÑÑ†Ñ–Ñ
    Logger.error("Time manipulation detected!", "Security")
    return { manipulated: true }
  end
  
  save_last_known_time(current_time)
  { manipulated: false }
end
```

### 2. VM Detection
```ruby
def running_in_vm?
  checks = [
    `wmic computersystem get model`.include?('Virtual'),
    `wmic bios get serialnumber`.include?('VMware'),
    File.exist?('C:\\Program Files\\VMware'),
    ENV['PROCESSOR_IDENTIFIER']&.include?('QEMU')
  ]
  
  checks.any?
end
```

### 3. Debugger Detection
```ruby
def debugger_attached?
  if RUBY_PLATFORM.include?('mingw')
    # Windows API check
    result = `tasklist /FI "IMAGENAME eq ruby.exe"`.include?('ruby.exe')
    # Ğ”Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ñ– Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¸...
  end
  false
end
```

---

## ğŸ’° Ğ’ĞĞ Ğ¢Ğ†Ğ¡Ğ¢Ğ¬ VS Ğ—ĞĞ¥Ğ˜Ğ¡Ğ¢

| Ğ Ñ–Ğ²ĞµĞ½ÑŒ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚Ñƒ | Ğ§Ğ°Ñ Ñ€Ğ¾Ğ·Ñ€Ğ¾Ğ±ĞºĞ¸ | Ğ’Ğ°Ñ€Ñ‚Ñ–ÑÑ‚ÑŒ | Piracy rate | ROI |
|----------------|--------------|----------|-------------|-----|
| **ĞĞµĞ¼Ğ°Ñ”** | 0 | $0 | 80-90% | âŒ |
| **Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¸Ğ¹ (Var 5)** | 3 Ğ´Ğ½Ñ– | $2K | 40-60% | âœ… Good |
| **Ğ¡ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹ (Var 2)** | 2-3 Ñ‚Ğ¸Ğ¶Ğ½Ñ– | $10K | 10-20% | âœ…âœ… Excellent |
| **Ğ’Ğ¸ÑĞ¾ĞºĞ¸Ğ¹ (Var 4)** | 3-4 Ñ‚Ğ¸Ğ¶Ğ½Ñ– | $15K | 2-5% | âœ…âœ… Excellent |
| **Maximum (Hybrid)** | 6 Ñ‚Ğ¸Ğ¶Ğ½Ñ–Ğ² | $25K | <1% | âœ… Good (ÑĞºÑ‰Ğ¾ high value) |

---

## ğŸ¯ Ğ¤Ğ†ĞĞĞ›Ğ¬ĞĞ† Ğ Ğ•ĞšĞĞœĞ•ĞĞ”ĞĞ¦Ğ†Ğ‡

### Ğ”Ğ»Ñ ProGran3 Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒÑ:

**ğŸ† Ğ’ĞĞ Ğ†ĞĞĞ¢ 2: Offline First + Grace Period**

**ĞĞ±Ò‘Ñ€ÑƒĞ½Ñ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ:**
1. âœ… Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ 8/10 Ğ·Ğ°Ñ…Ğ¸ÑÑ‚ vs 9/10 UX
2. âœ… ĞŸÑ€Ğ°Ñ†ÑÑ” offline (Ğ°Ñ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚Ğ¾Ñ€Ğ¸ Ñ‡Ğ°ÑÑ‚Ğ¾ Ğ² Ğ¿Ğ¾Ğ»Ñ–)
3. âœ… 7-day grace period (Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ½ÑŒĞ¾)
4. âœ… Hardware binding (Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° ĞºĞ¾Ğ¿Ñ–ÑĞ²Ğ°Ñ‚Ğ¸)
5. âœ… Server control (remote deactivation)
6. âœ… Ğ ĞµĞ°Ğ»Ñ–ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¹ timeline (2-3 Ñ‚Ğ¸Ğ¶Ğ½Ñ–)

**Implementation:**
- Week 1: Hardware fingerprinting + API
- Week 2: Encryption + Grace period logic
- Week 3: Testing + Polish

**Ğ—Ğ°Ñ…Ğ¸ÑÑ‚:**
- Hardware fingerprint â†’ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ½ĞµÑÑ‚Ğ¸
- Encryption â†’ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ñ€ĞµĞ´Ğ°Ğ³ÑƒĞ²Ğ°Ñ‚Ğ¸
- Grace period â†’ Ğ¿Ñ€Ğ°Ñ†ÑÑ” offline
- Heartbeat â†’ server Ğ¼Ğ¾Ğ¶Ğµ Ğ²Ñ–Ğ´ĞºĞ»Ğ¸ĞºĞ°Ñ‚Ğ¸
- HMAC signatures â†’ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ¿Ñ–Ğ´Ñ€Ğ¾Ğ±Ğ¸Ñ‚Ğ¸

**Result:** 
- Piracy rate: 10-20% (industry standard)
- Investment: $10K
- ROI: Excellent

---

**Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ğ¹ Ğ´Ğ¾ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ñ— Ñ€ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ— Ğ¾Ğ±Ñ€Ğ°Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚Ñƒ?** ğŸš€


